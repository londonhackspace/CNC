# Generated by PNCconf at Mon Sep 21 17:06:47 2015

loadrt trivkins
loadrt [EMCMOT]EMCMOT servo_period_nsec=[EMCMOT]SERVO_PERIOD num_joints=[TRAJ]AXES
loadrt hostmot2
loadrt hm2_pci config=" num_encoders=5 num_pwmgens=5 num_stepgens=1 sserial_port_0=100xxx" 
setp    hm2_5i25.0.watchdog.timeout_ns 5000000
loadrt pid names=pid.x,pid.y,pid.z,pid.a,pid.s
loadrt oneshot names=os1,os2,os3,os4,os5
loadrt not count=4
loadrt conv_float_s32 names=cnvf,cnvr,cnvs
loadrt debounce cfg=2
loadrt and2 count=12
loadrt or2 count=4
loadrt toggle count=1
loadrt toggle2nist count=1
loadrt flipflop names=ff1,ff2
loadrt near count=2
loadrt scale names=scale.sp,scale.jog,scale-fo,scale-ro,scale-so,scale-maxa,sc_a
loadrt abs names=abs.spindle
loadrt lowpass names=lowpass.spindle
loadrt limit1 count=2
loadrt limit2 count=1
loadrt mux2 count=2

addf hm2_5i25.0.read          servo-thread
addf motion-command-handler   servo-thread
addf motion-controller        servo-thread
addf pid.x.do-pid-calcs       servo-thread
addf pid.y.do-pid-calcs       servo-thread
addf pid.z.do-pid-calcs       servo-thread
addf pid.a.do-pid-calcs       servo-thread
addf pid.s.do-pid-calcs       servo-thread
addf hm2_5i25.0.write         servo-thread
addf os1                      servo-thread
addf os2                      servo-thread
addf os3                      servo-thread
addf os4                      servo-thread
addf os5                      servo-thread
addf not.0		      servo-thread
addf not.1		      servo-thread
addf not.2		      servo-thread
addf cnvf                     servo-thread
addf cnvr                     servo-thread
addf cnvs                     servo-thread
addf debounce.0 	      servo-thread
addf and2.0		      servo-thread
addf and2.1		      servo-thread
addf and2.2		      servo-thread
addf and2.3		      servo-thread
addf and2.4		      servo-thread
addf and2.5		      servo-thread
addf and2.6		      servo-thread
addf and2.7		      servo-thread
addf and2.8		      servo-thread
addf and2.9		      servo-thread
addf and2.10		      servo-thread
addf and2.11		      servo-thread
addf or2.0		      servo-thread
addf or2.1		      servo-thread
addf or2.2		      servo-thread
addf or2.3		      servo-thread
addf toggle.0		      servo-thread
addf toggle2nist.0	      servo-thread
addf ff1		      servo-thread
addf ff2		      servo-thread
addf near.0                   servo-thread
addf near.1                   servo-thread
addf scale.sp		      servo-thread
addf scale.jog   	      servo-thread
addf scale-fo   	      servo-thread
addf scale-ro   	      servo-thread
addf scale-so   	      servo-thread
addf scale-maxa   	      servo-thread
addf sc_a	   	      servo-thread
addf abs.spindle	      servo-thread
addf lowpass.spindle	      servo-thread
addf limit1.0		      servo-thread
addf limit1.1		      servo-thread
addf limit2.0		      servo-thread
addf mux2.0		      servo-thread
addf mux2.1		      servo-thread

###############################################################
# Estop output logic
###############################################################
# Enables 10CR to enable power up
# Drives DC Interlock relay
# Turns off power (estop) if dropped
# --- ESTOP-OUT ---
net emc-on  => hm2_5i25.0.7i77.0.0.output-00 <= halui.machine.is-on
net estop-loop iocontrol.0.user-enable-out iocontrol.0.emc-enable-in

###############################################################
# Estop input logic
###############################################################
# Combines Machine, spindle and encoder fault conditions
# --- Spindle-Fault ---
net spin-fault and2.4.in0 <= hm2_5i25.0.7i77.0.0.input-18
net spin-ok <= hm2_5i25.0.7i77.0.0.input-18-not

# --- Encoder-Faults ---
net enc-fault-x  <=  hm2_5i25.0.7i77.0.0.input-20-not and2.5.in0
net enc-fault-y  <=  hm2_5i25.0.7i77.0.0.input-21-not and2.5.in1
net enc-fault-z  <=  hm2_5i25.0.7i77.0.0.input-22-not and2.6.in1
# And all of the encoder siglas to xyzfault
net xyfault and2.6.in0 <= and2.5.out
net xyzfault and2.7.in0 <= and2.6.out

# --- ESTOP-IN ---
net estop-in   and2.4.in1 <= hm2_5i25.0.7i77.0.0.input-17 
net enc-spin  and2.4.out  =>  and2.7.in1
setp os4.falling TRUE
setp os4.rising FALSE
newsig os4Time float
net os4Time => os4.width
sets os4Time 1
# ext-estop is the consolidation of estop_in, spindle and encoder faults
net ext-estop <= and2.7.out => os4.in
net estop-pulse os4.out => halui.estop.activate

# --- Servo-On ---
net servo-on <= hm2_5i25.0.7i77.0.0.input-16

###############################################################
# Spindle control logic
###############################################################
# Generate start pulses
# Output a 1 second pulse on the leading edge of spindle-on
setp os1.falling FALSE
setp os1.rising TRUE
newsig os1Time float
net os1Time => os1.width
sets os1Time 1
net spindle-on os1.in
# --- SPINDLE-ON ---
net spindle-on-pulse os1.out => hm2_5i25.0.7i77.0.0.output-02

# Output a 1 second pulse to turn off spindle
# We delay turning off the spindle until it has stopped so that active
# decelleration is used.
# setup a near function to detect spindle stopped
net zero => near.1.in1
sets zero 0.0
net spindle-vel-cmd-rps => near.1.in2
setp near.1.scale 1.000000
setp near.1.difference 0.001
net spindle-stopped <= near.1.out => or2.1.in0
net spindle-on or2.1.in1

# Send an spindle off pulse if we get an estop
net emc-on => not.2.in
net emc-off <= not.2.out => or2.2.in0
net spindle-stopped-off <= or2.1.out => or2.2.in1

setp os2.falling FALSE
setp os2.rising TRUE
newsig os2Time float
net os2Time => os2.width
sets os2Time 1
net spindle-off <= or2.2.out => os2.in
# --- SPINDLE-OFF ---
net spindle-off-pulse os2.out => hm2_5i25.0.7i77.0.0.output-03

# Create a reset signal to clear spindle faults
setp os3.falling FALSE
setp os3.rising TRUE
newsig os3Time float
net os3Time => os3.width
sets os3Time 1
net servo-on => os3.in
# --- Spindle-Reset ---
net spin_reset os3.out => hm2_5i25.0.7i77.0.0.output-08

# --- Spindle-Dir ---
net spindle-ccw => hm2_5i25.0.7i77.0.0.output-09 <= motion.spindle-reverse

###############################################################
# Auto mode output signal, used to gate jog controls
###############################################################
# --- MACHINE-IS-ENABLED ---
net ModeIsManual halui.mode.is-manual => not.1.in
net ModeAuto not.1.out => hm2_5i25.0.7i77.0.0.output-01

###############################################################
# Axis enables
###############################################################
# --- X-ENABLE ---
net x-enable hm2_5i25.0.7i77.0.0.output-04

# --- Y-ENABLE ---
net y-enable hm2_5i25.0.7i77.0.0.output-05

# --- Z-ENABLE ---
net z-enable hm2_5i25.0.7i77.0.0.output-06

# --- A-ENABLE ---
net a-enable hm2_5i25.0.gpio.029.out
setp hm2_5i25.0.gpio.029.is_output TRUE
setp hm2_5i25.0.gpio.029.invert_output TRUE

###############################################################
# Overrides
###############################################################
# Read analog inputs from the override knobs. Full scale will be
# approximately 24v. Scale the input accordingly. 1.0 = 100%
#
# Scale up the raw values 100x so that when converted to integers we have
# good resolution. The results will be between 0 and 2400.
net scale_ovr => scale-fo.gain scale-ro.gain scale-so.gain
sets scale_ovr 100.0

# Read in analog input and send to halui.feed-override
# Enable direct count input
net fo-ena halui.feed-override.count-enable halui.feed-override.direct-value
sets fo-ena 1
# Scale down the value to a percentage
net scf-scale => halui.feed-override.scale
sets scf-scale 0.000852
# Convert from float to S32
# --- Feed Override ---
net scf-raw scale-fo.in   <=  hm2_5i25.0.7i77.0.0.analogin0
net scf-raw-adj cnvf.in   <=  scale-fo.out
net scf-s halui.feed-override.counts   <=  cnvf.out

# Read in analog input and send to halui.rapid-override
# Enable direct count input
net ro-ena halui.rapid-override.count-enable halui.rapid-override.direct-value
sets ro-ena 1
# Scale down the value to a percentage
net scr-scale => halui.rapid-override.scale
sets scr-scale 0.00044
# Convert from float to S32
# --- Rapid Override ---
net scr-raw scale-ro.in   <=  hm2_5i25.0.7i77.0.0.analogin1
net scr-raw-adj cnvr.in   <=  scale-ro.out
net scr-s halui.rapid-override.counts   <=  cnvr.out

# Read in analog input and send to halui.spindle-override
# Enable direct count input
net so-ena halui.spindle-override.count-enable halui.spindle-override.direct-value
sets so-ena 1
# Scale down the value to a percentage
net scs-scale => halui.spindle-override.scale
sets scs-scale 0.0005
# Add an offest so that we have a minimum override of 30%
net scs-offset => scale-so.offset
sets scs-offset 600
# Convert from float to S32
# --- Spindle Override ---
net scs-raw scale-so.in   <=  hm2_5i25.0.7i77.0.0.analogin2
net scs-raw-adj cnvs.in   <=  scale-so.out
net scs-s halui.spindle-override.counts   <=  cnvs.out

###############################################################
# External Program Pause/Resume and Run/Step Buttons
###############################################################
# Pause/Resume Section
setp debounce.0.delay 20
# --- STOP ---
net Stop_Btn debounce.0.0.in <= hm2_5i25.0.7i77.0.0.input-05
net pause-resume-btn and2.0.in0 and2.1.in0 <= debounce.0.0.out
net pause-on toggle2nist.0.is-on and2.0.in1 and2.3.in1 <= halui.program.is-paused
net run-on and2.1.in1 <= halui.program.is-running
net pause-sig or2.0.in0 <= and2.0.out
net resume-sig or2.0.in1 <= and2.1.out
net toggle-ok toggle.0.in <= or2.0.out
net togglesig toggle2nist.0.in <= toggle.0.out
net toggleon halui.program.pause <= toggle2nist.0.on
net toggleoff halui.program.resume <= toggle2nist.0.off
# Run/Step Section
# --- START ---
net run-step debounce.0.1.in hm2_5i25.0.7i77.0.0.input-04
net run-step-db and2.10.in0 <= debounce.0.1.out
net is-auto and2.10.in1 <= halui.mode.is-auto
net run-step-gated and2.2.in0 and2.3.in0 <= and2.10.out
net idle-on and2.2.in1 <= halui.program.is-idle
net run-sig halui.program.run <= and2.2.out
net step-sig halui.program.step <= and2.3.out

###############################################################
# Jog signals
###############################################################
# --- JOG-X-POS ---
net jog-x-pos   <=  hm2_5i25.0.7i77.0.0.input-06 => halui.jog.0.plus
# --- JOG-X-NEG ---
net jog-x-neg   <=  hm2_5i25.0.7i77.0.0.input-07 => halui.jog.0.minus
# --- JOG-Y-POS ---
net jog-y-pos   <=  hm2_5i25.0.7i77.0.0.input-08 => halui.jog.1.plus
# --- JOG-Y-NEG ---
net jog-y-neg   <=  hm2_5i25.0.7i77.0.0.input-09 => halui.jog.1.minus
# --- JOG-Z-POS ---
net jog-z-pos   <=  hm2_5i25.0.7i77.0.0.input-10 => halui.jog.2.plus
# --- JOG-Z-NEG ---
net jog-z-neg   <=  hm2_5i25.0.7i77.0.0.input-11 => halui.jog.2.minus
# --- JOG-Rapid ---
# Joystick switches (currently unused)
#net jog-continuous <=  hm2_5i25.0.7i77.0.0.input-12

# Jog rates 
# Select the limited rate when we jog z minus
setp limit1.0.max 28
net jog-speed      =>  limit1.0.in  => mux2.0.in0
net jog-speed-lim  <= limit1.0.out =>  mux2.0.in1
net jog-z-neg      => mux2.0.sel
net jog-speed-sel  <= mux2.0.out => halui.jog-speed

###############################################################
# Home switch inputs
###############################################################
# --- HOME-X ---
net home-x        <=  hm2_5i25.0.7i77.0.0.input-13

# --- HOME-Y ---
net home-y        <=  hm2_5i25.0.7i77.0.0.input-14

# --- HOME-Z ---
net home-z        <=  hm2_5i25.0.7i77.0.0.input-15

###############################################################
# Probe input & output
###############################################################
net probe-in <= hm2_5i25.0.7i77.0.0.input-23 => or2.3.in0
net toolset-in <= hm2_5i25.0.7i77.0.0.input-24 => or2.3.in1
net probe-signal <= or2.3.out => motion.probe-input
# Output a short pulse to the probe LED/Beeper on contact
setp os5.falling FALSE
setp os5.rising TRUE
newsig os5Time float
net os5Time => os5.width
sets os5Time 0.02
net probe-signal => os5.in
net probe-led <= os5.out => hm2_5i25.0.7i77.0.0.output-10

#*******************
#  AXIS X
#*******************
setp   pid.x.Pgain     [AXIS_0]P
setp   pid.x.Igain     [AXIS_0]I
setp   pid.x.Dgain     [AXIS_0]D
setp   pid.x.bias      [AXIS_0]BIAS
setp   pid.x.FF0       [AXIS_0]FF0
setp   pid.x.FF1       [AXIS_0]FF1
setp   pid.x.FF2       [AXIS_0]FF2
setp   pid.x.deadband  [AXIS_0]DEADBAND
setp   pid.x.maxoutput [AXIS_0]MAX_OUTPUT
setp   pid.x.error-previous-target true
setp   pid.x.maxerror .0005

net x-index-enable  <=> pid.x.index-enable
net x-enable        =>  pid.x.enable
net x-pos-cmd       =>  pid.x.command
net x-vel-cmd       =>  pid.x.command-deriv
net x-pos-fb        =>  pid.x.feedback
net x-output        =>  pid.x.output

# ---PWM Generator signals/setup---

setp   hm2_5i25.0.7i77.0.1.analogout0-scalemax  [AXIS_0]OUTPUT_SCALE
setp   hm2_5i25.0.7i77.0.1.analogout0-minlim    [AXIS_0]OUTPUT_MIN_LIMIT
setp   hm2_5i25.0.7i77.0.1.analogout0-maxlim    [AXIS_0]OUTPUT_MAX_LIMIT

net x-output => hm2_5i25.0.7i77.0.1.analogout0
net x-pos-cmd    axis.0.motor-pos-cmd
net x-enable     axis.0.amp-enable-out
# enable _all_ sserial pwmgens
net x-enable   hm2_5i25.0.7i77.0.1.analogena

# ---Encoder feedback signals/setup---

setp    hm2_5i25.0.encoder.00.counter-mode 0
setp    hm2_5i25.0.encoder.00.filter 1
setp    hm2_5i25.0.encoder.00.index-invert 0
setp    hm2_5i25.0.encoder.00.index-mask 0
setp    hm2_5i25.0.encoder.00.index-mask-invert 0
setp    hm2_5i25.0.encoder.00.scale  [AXIS_0]ENCODER_SCALE

net x-pos-fb               <=  hm2_5i25.0.encoder.00.position
net x-vel-fb               <=  hm2_5i25.0.encoder.00.velocity
net x-pos-fb               =>  axis.0.motor-pos-fb
net x-index-enable    axis.0.index-enable  <=>  hm2_5i25.0.encoder.00.index-enable
net x-pos-rawcounts        <=  hm2_5i25.0.encoder.00.rawcounts

# ---setup home / limit switch signals---

net home-x     =>  axis.0.home-sw-in

#*******************
#  AXIS Y
#*******************
setp   pid.y.Pgain     [AXIS_1]P
setp   pid.y.Igain     [AXIS_1]I
setp   pid.y.Dgain     [AXIS_1]D
setp   pid.y.bias      [AXIS_1]BIAS
setp   pid.y.FF0       [AXIS_1]FF0
setp   pid.y.FF1       [AXIS_1]FF1
setp   pid.y.FF2       [AXIS_1]FF2
setp   pid.y.deadband  [AXIS_1]DEADBAND
setp   pid.y.maxoutput [AXIS_1]MAX_OUTPUT
setp   pid.y.error-previous-target true
setp   pid.y.maxerror .0005

net y-index-enable  <=> pid.y.index-enable
net y-enable        =>  pid.y.enable
net y-pos-cmd       =>  pid.y.command
net y-vel-cmd       =>  pid.y.command-deriv
net y-pos-fb        =>  pid.y.feedback
net y-output        =>  pid.y.output

# ---PWM Generator signals/setup---

setp   hm2_5i25.0.7i77.0.1.analogout1-scalemax  [AXIS_1]OUTPUT_SCALE
setp   hm2_5i25.0.7i77.0.1.analogout1-minlim    [AXIS_1]OUTPUT_MIN_LIMIT
setp   hm2_5i25.0.7i77.0.1.analogout1-maxlim    [AXIS_1]OUTPUT_MAX_LIMIT

net y-output                             => hm2_5i25.0.7i77.0.1.analogout1
net y-pos-cmd    axis.1.motor-pos-cmd
net y-enable     axis.1.amp-enable-out

# ---Encoder feedback signals/setup---

setp    hm2_5i25.0.encoder.01.counter-mode 0
setp    hm2_5i25.0.encoder.01.filter 1
setp    hm2_5i25.0.encoder.01.index-invert 0
setp    hm2_5i25.0.encoder.01.index-mask 0
setp    hm2_5i25.0.encoder.01.index-mask-invert 0
setp    hm2_5i25.0.encoder.01.scale  [AXIS_1]ENCODER_SCALE

net y-pos-fb               <=  hm2_5i25.0.encoder.01.position
net y-vel-fb               <=  hm2_5i25.0.encoder.01.velocity
net y-pos-fb               =>  axis.1.motor-pos-fb
net y-index-enable    axis.1.index-enable  <=>  hm2_5i25.0.encoder.01.index-enable
net y-pos-rawcounts        <=  hm2_5i25.0.encoder.01.rawcounts

# ---setup home / limit switch signals---

net home-y     =>  axis.1.home-sw-in

#*******************
#  AXIS Z
#*******************
setp   pid.z.Pgain     [AXIS_2]P
setp   pid.z.Igain     [AXIS_2]I
setp   pid.z.Dgain     [AXIS_2]D
setp   pid.z.bias      [AXIS_2]BIAS
setp   pid.z.FF0       [AXIS_2]FF0
setp   pid.z.FF1       [AXIS_2]FF1
setp   pid.z.FF2       [AXIS_2]FF2
setp   pid.z.deadband  [AXIS_2]DEADBAND
setp   pid.z.maxoutput [AXIS_2]MAX_OUTPUT
setp   pid.z.error-previous-target true
setp   pid.z.maxerror .0005

net z-index-enable  <=> pid.z.index-enable
net z-enable        =>  pid.z.enable
net z-pos-cmd       =>  pid.z.command
net z-pos-fb        =>  pid.z.feedback
net z-output        =>  pid.z.output

# ---PWM Generator signals/setup---

setp   hm2_5i25.0.7i77.0.1.analogout2-scalemax  [AXIS_2]OUTPUT_SCALE
setp   hm2_5i25.0.7i77.0.1.analogout2-minlim    [AXIS_2]OUTPUT_MIN_LIMIT
setp   hm2_5i25.0.7i77.0.1.analogout2-maxlim    [AXIS_2]OUTPUT_MAX_LIMIT

net z-output     => hm2_5i25.0.7i77.0.1.analogout2
net z-pos-cmd    axis.2.motor-pos-cmd
net z-enable     axis.2.amp-enable-out

# ---Encoder feedback signals/setup---

setp    hm2_5i25.0.encoder.02.counter-mode 0
setp    hm2_5i25.0.encoder.02.filter 1
setp    hm2_5i25.0.encoder.02.index-invert 0
setp    hm2_5i25.0.encoder.02.index-mask 0
setp    hm2_5i25.0.encoder.02.index-mask-invert 0
setp    hm2_5i25.0.encoder.02.scale  [AXIS_2]ENCODER_SCALE

net z-pos-fb               <=  hm2_5i25.0.encoder.02.position
net z-vel-fb               <=  hm2_5i25.0.encoder.02.velocity
net z-pos-fb               =>  axis.2.motor-pos-fb
net z-index-enable    axis.2.index-enable  <=>  hm2_5i25.0.encoder.02.index-enable
net z-pos-rawcounts        <=  hm2_5i25.0.encoder.02.rawcounts

# ---setup home / limit switch signals---

net home-z     =>  axis.2.home-sw-in

#*******************
#  AXIS A
#*******************

setp   pid.a.Pgain     [AXIS_3]P
setp   pid.a.Igain     [AXIS_3]I
setp   pid.a.Dgain     [AXIS_3]D
setp   pid.a.bias      [AXIS_3]BIAS
setp   pid.a.FF0       [AXIS_3]FF0
setp   pid.a.FF1       [AXIS_3]FF1
setp   pid.a.FF2       [AXIS_3]FF2
setp   pid.a.deadband  [AXIS_3]DEADBAND
setp   pid.a.maxoutput [AXIS_3]MAX_OUTPUT
setp   pid.a.error-previous-target true
setp   pid.a.maxerror .0005

net a-index-enable  <=> pid.a.index-enable
net a-enable        =>  pid.a.enable
net a-pos-cmd       =>  pid.a.command
net a-vel-cmd       =>  pid.a.command-deriv
net a-pos-fb        =>  pid.a.feedback
net a-output        <=  pid.a.output

# Step Gen signals/setup

setp   hm2_5i25.0.stepgen.00.dirsetup        [AXIS_3]DIRSETUP
setp   hm2_5i25.0.stepgen.00.dirhold         [AXIS_3]DIRHOLD
setp   hm2_5i25.0.stepgen.00.steplen         [AXIS_3]STEPLEN
setp   hm2_5i25.0.stepgen.00.stepspace       [AXIS_3]STEPSPACE
setp   hm2_5i25.0.stepgen.00.position-scale  [AXIS_3]STEP_SCALE
setp   hm2_5i25.0.stepgen.00.step_type        0
setp   hm2_5i25.0.stepgen.00.control-type     1
setp   hm2_5i25.0.stepgen.00.maxaccel         [AXIS_3]STEPGEN_MAXACCEL
setp   hm2_5i25.0.stepgen.00.maxvel           [AXIS_3]STEPGEN_MAXVEL

# ---closedloop stepper signals---

net a-pos-cmd    <= axis.3.motor-pos-cmd
net a-vel-cmd    <= axis.3.joint-vel-cmd
net a-output     => hm2_5i25.0.stepgen.00.velocity-cmd
net a-pos-fb     <= hm2_5i25.0.stepgen.00.position-fb
net a-pos-fb     => axis.3.motor-pos-fb
net a-enable     <= axis.3.amp-enable-out
net a-enable     => hm2_5i25.0.stepgen.00.enable
setp hm2_5i25.0.gpio.017.invert_output FALSE
setp hm2_5i25.0.gpio.018.invert_output TRUE

#*******************
#  SPINDLE S
#*******************

setp   pid.s.Pgain     [SPINDLE_9]P
setp   pid.s.Igain     [SPINDLE_9]I
setp   pid.s.Dgain     [SPINDLE_9]D
setp   pid.s.bias      [SPINDLE_9]BIAS
setp   pid.s.FF0       [SPINDLE_9]FF0
setp   pid.s.FF1       [SPINDLE_9]FF1
setp   pid.s.FF2       [SPINDLE_9]FF2
setp   pid.s.deadband  [SPINDLE_9]DEADBAND
setp   pid.s.maxoutput [SPINDLE_9]MAX_OUTPUT
setp   pid.s.error-previous-target true
setp   pid.s.maxerror .1

net spindle-index-enable  <=> pid.s.index-enable
net spindle-enable        =>  pid.s.enable
# Enable spindle all of the time so that we have decceleration
sets spindle-enable True
net spindle-vel-cmd-rpm-ramped  => pid.s.command 
net spindle-fb-rpm-abs          => pid.s.feedback
net spindle-output             <=  pid.s.output

# ---PWM Generator signals/setup---

setp   hm2_5i25.0.7i77.0.1.analogout4-scalemax  [SPINDLE_9]OUTPUT_SCALE
setp   hm2_5i25.0.7i77.0.1.analogout4-minlim    [SPINDLE_9]OUTPUT_MIN_LIMIT
setp   hm2_5i25.0.7i77.0.1.analogout4-maxlim    [SPINDLE_9]OUTPUT_MAX_LIMIT

net spindle-output        => hm2_5i25.0.7i77.0.1.analogout4 

# ---Encoder feedback signals/setup---

setp    hm2_5i25.0.encoder.04.counter-mode 0
setp    hm2_5i25.0.encoder.04.filter 1
setp    hm2_5i25.0.encoder.04.index-invert 0
setp    hm2_5i25.0.encoder.04.index-mask 0
setp    hm2_5i25.0.encoder.04.index-mask-invert 0
setp    hm2_5i25.0.encoder.04.scale  [SPINDLE_9]ENCODER_SCALE

net spindle-revs             <=   hm2_5i25.0.encoder.04.position
net spindle-revs              =>  motion.spindle-revs
net spindle-fb-rps           <=   hm2_5i25.0.encoder.04.velocity
net spindle-fb-rps            =>  motion.spindle-speed-in
net spindle-index-enable     <=>  hm2_5i25.0.encoder.04.index-enable
net spindle-index-enable      =>  motion.spindle-index-enable

# Spindle-velocity bounces around so we filter it with lowpass.
# Spindle-velocity is signed so we use absolute component to remove sign.
# Velocity is in RPS not RPM so we scale it.
setp     scale.sp.gain 60
setp     lowpass.spindle.gain [SPINDLE_9]LP_FILTER
net spindle-fb-rps            =>     scale.sp.in
net spindle-fb-rpm           <= scale.sp.out       => abs.spindle.in
net spindle-fb-rpm-abs       <= abs.spindle.out    => lowpass.spindle.in
net spindle-fb-rpm-abs-filtered  <= lowpass.spindle.out


# ---setup spindle control signals---

net spindle-vel-cmd-rps        <=  motion.spindle-speed-out-rps
net spindle-vel-cmd-rpm-abs    <=  motion.spindle-speed-out-abs
# Limit ramp up and down of the speed, max RPM change per second.
setp limit2.0.maxv [SPINDLE_9]RPM_MAX_CHANGE
net spindle-vel-cmd-rpm-abs    => limit2.0.in
net spindle-vel-cmd-rpm-ramped <= limit2.0.out
net spindle-on                 <=  motion.spindle-on

# ---setup spindle at speed signals---

# An AT_SPEED value of 1.1 = 10%, 1.05 = 5%, etc.
net spindle-fb-rpm-abs-filtered   =>  near.0.in1
net spindle-vel-cmd-rpm-ramped    =>  near.0.in2
net at-speed                     <=  near.0.out  => and2.9.in1
net spindle-on                    => and2.9.in0
net spindle-at-speed             <=  and2.9.out
setp near.0.scale [SPINDLE_9]AT_SPEED
setp near.0.difference 0
net spindle-at-speed              =>  motion.spindle-at-speed

###############################################################
# Jogwheel signals 
# shared MPG
###############################################################
net joint-selected-count     <=  hm2_5i25.0.encoder.03.count

#       for axis x MPG
setp    axis.0.jog-vel-mode 0
net selected-jog-incr    =>  axis.0.jog-scale
net jog-ena-x            =>  axis.0.jog-enable
net joint-selected-count =>  axis.0.jog-counts

#       for axis y MPG
setp    axis.1.jog-vel-mode 0
net selected-jog-incr    =>  axis.1.jog-scale
net jog-ena-y            =>  axis.1.jog-enable
net joint-selected-count =>  axis.1.jog-counts

#       for axis z MPG
setp    axis.2.jog-vel-mode 0
# Limit Z motion, should be about 24 FPM
setp	limit1.1.max [MPG]Z_MINUS_LIMIT
net selected-jog-incr    =>  limit1.1.in
net selected-jog-incr-z <= limit1.1.out  =>  axis.2.jog-scale
net jog-ena-z            =>  axis.2.jog-enable
net joint-selected-count =>  axis.2.jog-counts

#       for axis a MPG
# Multiply the rate for A by 14
setp    axis.3.jog-vel-mode 0
setp sc_a.gain 14
net selected-jog-incr    =>  sc_a.in
net selected-jog-incr-a  <= sc_a.out  =>  axis.3.jog-scale
net jog-ena-a            =>  axis.3.jog-enable
net joint-selected-count =>  axis.3.jog-counts


# Scale the jog rate (FPM) to an increment per Handwheel count
setp     scale.jog.gain [MPG]HAND_WHEEL_SCALE
net jog-speed		=> scale.jog.in
net selected-jog-incr  <=  scale.jog.out
